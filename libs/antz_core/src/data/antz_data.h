//
// Created by Kenneth Gulbrandsøy on 18/05/2025.
//

#pragma once

#include <array>
#include <cstdint>
#include <optional>

// ANT extended messaging allows for the transmitting device’s channel ID
// (transmission type, device type and device number) to be passed to the
// host through the extended data bytes. If channel ID extended messaging
// is enabled, the flag byte will include 0x80 to indicate that channel ID
// information is present in the extended data bytes. An extended message
// that includes channel ID information will look like that in Figure 7-2.
// Channel ID Output is the only extended information available via the
// legacy-extended format.
struct device_channel_id_info_t {
    // The device number is a 16-bit field that is meant to be
    // unique for a given device type. Typically, this may be
    // correlated to the serial number of the device, or it could
    // be a random number generated by the device if the process
    // of setting serial numbers for a particular product is
    // unavailable. This parameter must be specified on a master
    // device, i.e., it cannot be set to zero. In a slave device,
    // this field may also be used as a wild card during device
    // pairing as described in the previous section. Please note
    // that the device number should not be set to 0x0000 or
    // 0xFFFF as these are reserved values, particularly if the
    // device number is derived from the serial number.
    uint16_t device_number = 0;

    // The device type is an 8-bit field used to denote the type
    // (or class) of each participating network device. This field
    // is used to differentiate between multiple nodes of network
    // devices such that participants are aware of the various
    // classes of connected nodes and can decode the received data
    // accordingly. For example, one device type value could be
    // assigned to heart rate monitors, which will be different to
    // the value assigned to bike speed sensors, and their respective
    // data payloads will be interpreted accordingly. Please note
    // that the most significant bit of the Device Type is a device
    // pairing bit. This parameter must be specified on a master
    // device; however, it can be set to zero (wildcard) on a slave
    // device.
    uint8_t device_type = 0;

    // The transmission type is an 8-bit field used to define certain
    // transmission characteristics of a device. Specifically, the two
    // least significant bits of the transmission type are used to indicate
    // the presence, and size, of a shared address field at the beginning
    // of the data payload. The third least significant bit (LSB) is
    // used to indicate the presence of a Global Data Identification
    // Byte (such as ANT+ page numbers). The most significant nibble
    // may optionally be used to extend the device number from 16 bits
    // to 20 bits. In this case, the transmission type most significant
    // nibble becomes the most significant nibble of the 20 bit device
    // number. This parameter must be specified on a master device;
    // however, it can be set to zero (wildcard) on a slave device.
    uint8_t transmission_type = 0;

};

// Lib Config (0x6E) provides a way to receive the RSSI, or received signal
// strength indication, in addition to the 8-byte data payload. If RSSI extended
// messaging is enabled, the flag byte will include 0x40 to indicate that RSSI
// information is present in the extended data bytes. The received message
// including RSSI output is shown in Figure 7-3. For more information on RSSI
// extended messaging, refer to the “RSSI Extended Messaging” application note.
struct rssi_info_t {
    // The measurement value represents the measurement type of
    // the received data message, and indicates how to interpret
    // the RSSI Value field. The measurement type will be 0x20,
    // which refers to DBM type. DBM type indicates that the RSSI
    // value is taken in units of dBm. If the measurement type is
    // any other value, do not decode any other bytes in the
    // extended RSSI data. For more information refer to the
    // “RSSI Extended Messaging” application note.
    uint8_t type = 0;

    // The RSSI value is a signed integer that corresponds
    // to the measured RSSI value in dBm (can be negative).
    int8_t value = 0;

    // The threshold configuration value is used to indicate
    // the dBm value of the bin configured using the
    // Proximity Search command. The default value is -128dB,
    //  which corresponds to an effective “Off” setting.
    uint8_t threshold = 0;

};

// A device that supports the Lib Config command can also be configured to receive
// timestamp data along with the 8-byte data payload. A flag byte of 0x20 indicates
// that a device can expect timestamp information in the extended data bytes. The
// received extended message for timestamp output is show in Figure 7-4.
struct rx_timestamp_info_t {
    // The Rx Timestamp is a 2 byte field (16-bit value) that rolls
    // over every 2 seconds. This value is in little endian format.
    // The timestamp is based on a 32.768 kHz clock and is subject
    // to variance due to clock drift. The Rx timestamp is generated
    // exactly when the message was received by ANT over the air.
    uint32_t timestamp_ms;

};

// All ANT message extension fields (set present fields as needed)
struct ant_ext_fields_t {
    // Extension flags byte
    std::optional<uint8_t> flags;

    // Device’s channel ID
    std::optional<device_channel_id_info_t> device_channel_id;

    // RSSI extension data
    std::optional<rssi_info_t> rssi;

    // RX timestamp extension data
    std::optional<rx_timestamp_info_t> rx_timestamp;

    // Length of extended info in bytes
    uint8_t length = 0;

};

// Container for a raw ANT message packet with parsed extensions
struct ant_data_t {
    uint8_t msg_id;
    uint8_t msg_len;
    std::array<uint8_t, 8> payload;
    std::optional<uint8_t> channel;
    std::optional<ant_ext_fields_t> ext;
};

namespace antz
{
    const char* format_ext_flags(u_int8_t flags);
    const char* format_device_channel_id(const ant_ext_fields_t& ext);

    /**
     * Parses extended fields from an ANT+ message to extract additional metadata such as
     * RSSI, device channel ID, and receive timestamp if present.
     *
     * @param data Pointer to the ANT+ message data.
     * @param length Length of the message data in bytes.
     * @param ext Reference to an ant_ext_fields_t object where the parsed extended fields will be stored.
     *
     * @return True if extended fields are successfully parsed and populated; false otherwise.
     *
     * Extended fields include:
     * - Device Channel ID (enabled with CHANNEL_ID_EXT_FLAG at data[9])
     * - RSSI (enabled with RSSI_EXT_FLAG at data[9])
     * - Rx Timestamp (enabled with RX_TIMESTAMP_FLAG at data[9])
     *
     * Parsing rules:
     * - If the message length is less than 10 bytes, extended fields cannot be parsed, and false is returned.
     * - Flags from data[9] are used to determine if extended fields are present.
     * - For each flag, the corresponding data is extracted starting at a specific offset (data[10]).
     * - The `ext` object is updated with the parsed metadata if the fields are present.
     * - If the total length of parsed fields exceeds the message length, false is returned and a warning is issued.
     */
    bool parse_ext_fields(const uint8_t* data, uint8_t length, ant_ext_fields_t& ext);

    /**
     * Processes the received ANT Message and extracts the data if msg_id accepted.
     *
     * @param msg_id The message identifier, which determines the type of ANT message.
     * @param data A pointer to the raw data payload received from the ANT message.
     * @param data_len The length of the data payload provided in the ANT message.
     * @return An optional ant_data_t object containing the parsed and extracted data
     *         if the message ID matches the expected values, otherwise returns std::nullopt.
     */
    std::optional<ant_data_t> handle_ant_message(uint8_t msg_id, const uint8_t* data, size_t data_len);

}
