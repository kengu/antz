//
// Created by Kenneth Gulbrandsøy on 03/07/2025.
//

#pragma once

#include "logger/antz_logger.h"

// -------------------------------------------------------------------
// Rationale of antz_xmacro_logging.h
// -------------------------------------------------------------------
//
// This logger implementation uses an X-macro table to define all log message types in one place,
// specifying their ID, log level, printf-style format string, and argument list. The X-macro approach
// ensures that log message definitions, format strings, and associated helper functions remain consistent
// and easy to maintain, reducing the risk of mismatches.
//
// Key points:
// - All log messages are specified in a single table with their format, level, and typed arguments.
// - The macro generates:
//     - An enum for log message IDs.
//     - Tables for format strings and log levels, used at runtime.
//     - Inline wrapper functions for each log message type to enforce type safety.
//     - A main logger macro (ANTZ_LOGF) that checks the log level at compile time (if constexpr).
// - This scheme allows you to add or change log messages in just one place and ensures all functions
//   and data stay in sync.
// - The implementation is header-only for simplicity and efficiency; all logger helpers are inline.
// - The main logger macro can be enabled or disabled at compile time using the ANTZ_LOG_ENABLE macro.
// - The design avoids problematic macro expansion errors by generating only simple, type-safe
//   wrapper functions per log message.
//
// Benefits:
// - Centralized maintenance: change/add messages in one place
// - Type safety: wrapper functions enforce consistent argument types
// - Efficiency: uses compile-time constants for log levels and format strings
// - Flexibility: log output can be filtered by minimum level using ANTZ_LOG_MIN_LEVEL
// - Easy to extend: add new log messages to the X-macro table as needed
// - Platform agnostic: logger backend can be adapted to resource-constrained embedded systems
//
// -------------------------------------------------------------------
// Compile-time Logging Enable/Disable: ANTZ_LOG_ENABLE
// -------------------------------------------------------------------
//
// The `ANTZ_LOG_ENABLE` macro controls whether any logging code is compiled in.
// If `ANTZ_LOG_ENABLE` is defined (to any value), logging macros and helper functions
// generated by the X-macro table are active and will generate logging calls.
//
// If `ANTZ_LOG_ENABLE` is **not** defined, all of these logging macros and functions
// will expand to nothing at compile time. This means:
//   - There is no logging code or code size/performance overhead in your final binary.
//   - All log-related calls (including argument evaluation) are entirely omitted.
//   - This is useful for production, release builds, or resource-constrained targets
//     where logging is not needed.
//
//
// To enable logging, define `ANTZ_LOG_ENABLE` (for example, by adding `-DANTZ_LOG_ENABLE`
// to your compiler flags, or via a global header).
// To completely disable logging, avoid defining this macro.
//
// -------------------------------------------------------------------
// Defining the Log Message Table
// -------------------------------------------------------------------
// All log messages should be defined in a single macro table.
// By convention, this macro table is named MSGS, but you may choose a different name
// if needed for your context. Just be consistent and update relevant uses.
//
// Example:
//
//    #define MSGS(X) \
//        X(LOG, INIT_DONE, antz::LogLevel::Info,               \
//          "Initialization finished for device: %s",           \
//          (const char* deviceName), deviceName)
//
// -------------------------------------------------------------------
// Log Wrapper Function Naming
// -------------------------------------------------------------------
// Each log message definition results in an inline wrapper function named
// using the pattern:
//
//   <MODULE>_LOG_<NAME>(...);
//
// where <MODULE> is the category or scope (e.g., LOG), and <NAME> is your
// message id.
//
// For example, the macro entry:
//    X(LOG, INIT_DONE, ...)
//
// will generate a function:
//    LOG_LOG_INIT_DONE(args...);
//
// Use this pattern when calling logging functions from your code.
//
// -------------------------------------------------------------------
// Adding log messages (for documentation)
// -------------------------------------------------------------------
// When adding a X MACRO table entry like this
//
//      #define MSGS(X)                                         \
//          ... existing log messages ...                       \
//          X(SOME, FOO_EVENT, antz::LogLevel::Info,            \
//              "Foo happened with bar=%d and baz=%s",          \
//              (int bar, const char* baz), bar, baz)
//
//  the preprocessor will expand it to
//
//      SOME_LOG_FOO_EVENT(int bar, const char* baz)
//
//  And if you call it with
//
//      SOME_LOG_FOO_EVENT(43, 'life')
//
//  it will log the message:
//
//      [INFO] Foo happened with bar=43 and baz=life
//
//  if and only if antz::LogLevel::Info >= ANTZ_LOG_MIN_LEVEL
//
// -------------------------------------------------------------------
// Generating Module Log Methods with ANTZ_XMACRO_LOGS
// -------------------------------------------------------------------
//
// Use the `ANTZ_XMACRO_LOGS(<MODULE>, <LOG_MSG_TABLE>)` macro to automatically
// generate all the type-safe log wrapper functions for a specific module.
//
// - `<MODULE>` should be a unique tag for your module (e.g., ANTZ_CORE, ANTZ_PLATFORM).
// - `<LOG_MSG_TABLE>` is the X-macro table containing your module’s log message definitions.
//
// This macro produces:
//   - An enum listing all log message IDs for that module
//   - Arrays mapping log IDs to their format strings and log levels
//   - One inline wrapper function per log message, enforcing correct arguments
//
// These helpers can be called directly (e.g., `SOME_LOG_FOO(...)`),
// making module logging easy and safe throughout your codebase.
//
// To use, place (typically in your module’s logging header):
//     #include "logger/antz_xmacro_logger.h"
//     ANTZ_XMACRO_LOGS(SOME, SOME_LOG_MSGS)
//
// This generates everything needed for your module’s logging in a header-only fashion.
//
// -------------------------------------------------------------------
// Auto-Generated formatted message Methods
// -------------------------------------------------------------------
//
// For each log message defined via the X-macro table, a `MSGF` helper function is generated.
// These functions allow you to produce a formatted, human-readable version of any log message
// without emitting it to the logger backend.
//
// Usage example:
//     const char* msg = SOME_MSGF_FOO(channel, msg_id, ext_info, length, hex_str);
//
// Purpose and properties:
//   - `MSGF` functions use the same strongly typed argument list as the corresponding log method.
//   - They return a temporary pointer to a buffer containing the formatted result, following
//     the format string defined in the log table.
//
// Safety and limitations:
//   - The returned pointer is valid only until the next call to any `MSGF` or similar formatting
//     function on the same thread. Do not store or use the pointer later.
//   - The message will be truncated if it exceeds the maximum buffer size (`MAX_LOG_BUFFER`).
//   - Multiple `MSGF` calls in a single expression may conflict due to reuse of the buffer.
//
// When to use:
//   - Generating log messages for use in assertions, test expectations, or as part of composite outputs.
//   - Viewing what a log would look like, without actually logging it.
//
// This pattern ensures you have a safe, no-logging way to format messages that exactly match your
// runtime log output.
//
// Note that `MSGF` functions are not generated if ANTZ_LOG_ENABLE is false.
//
// -------------------------------------------------------------------
// Formatting Messages: formatf (messagef)
// -------------------------------------------------------------------
//
// The `formatf` function is a lightweight utility for producing formatted
// messages as C strings using printf-style syntax. It can be used to generate
// log strings or diagnostic outputs.
//
// Usage example:
//     const char* msg = antz::formatf("Count: %d, Name: %s", count, name);
//
// `formatf` accepts a format string and additional arguments, returning a pointer
// to a temporary buffer containing the formatted result. This buffer is reused
// on each call, so the returned pointer should **not** be stored for later use.
// Each call to `formatf` will overwrite the contents from any previous call in
// the same thread.
//
// Practical use cases:
//   - Quickly assembling informative strings for logs or assertions
//   - On-the-fly message composition when direct logging isn’t suitable
//
// **Safety note:** Because the buffer is temporary and may be shared among
// calls, you should use the returned string immediately.
//
// Buffer size and lifetime:
//   - Limited in length (see `MAX_LOG_BUFFER`), so messages will be truncated
//     if too long.
//   - The buffer is only valid until the next call to `formatf` or related
//     formatting utilities in the same thread.
//
// This utility ensures you can format human-readable messages consistently
// across your codebase without manual buffer management.
//
// -------------------------------------------------------------------
// Header-only Design Notes
// -------------------------------------------------------------------
// All logger helpers are defined as inline functions within the header.
//
// This approach means:
//   - No additional .cpp files are required for logging features.
//   - Calls are directly inlined by the compiler, avoiding function call overhead.
//   - There is no risk of multiple definition linker errors if included in several source files.
//
// In general, because each log wrapper is small and inlined, there is
// minimal impact on code size or binary bloat. However, if you add a very
// large number of log messages, you may wish to review your compiler's inlining
// and size optimizations.
//
// This scheme is both convenient and efficient for most embedded and application scenarios.
//
// -------------------------------------------------------------------
// Important
// -------------------------------------------------------------------
//
//  If the global logger pointer g_logger (declared in antz_logger.h)
//  is not initialized, calls to logging functions generated via the
//  X macros will be silently ignored.
//

#ifndef ANTZ_LOG_ENABLE
#define ANTZ_LOG_ENABLE 1
#endif

#ifndef ANTZ_LOG_MIN_LEVEL
#define ANTZ_LOG_MIN_LEVEL antz::LogLevel::Info
#endif

    #define ANTZ_XMACRO_LOGS(PREFIX, XMACRO_REPTABLE)                                       \
        enum class PREFIX##_msg_e {                                                         \
            XMACRO_REPTABLE(ANTZ_MSG_X_ID)                                                  \
            COUNT                                                                           \
        };                                                                                  \
        inline constexpr const char* PREFIX##_msg_formats[] = {                             \
            XMACRO_REPTABLE(ANTZ_MSG_X_FORMAT)                                              \
        };                                                                                  \
        inline const char* PREFIX##_messagef(PREFIX##_msg_e msg_id, ...) {                  \
            va_list ap;                                                                     \
            va_start(ap, msg_id);                                                           \
            const char* result = antz::formatf(PREFIX##_msg_formats[int(msg_id)], ap);      \
            va_end(ap);                                                                     \
            return result;                                                                  \
        }                                                                                   \
        XMACRO_REPTABLE(ANTZ_MSG_X_STRINGF)                                                 \
        inline constexpr antz::LogLevel PREFIX##_log_levels[] = {                           \
            XMACRO_REPTABLE(ANTZ_LOG_X_LEVEL)                                               \
        };                                                                                  \
        XMACRO_REPTABLE(ANTZ_LOG_X_FUNCTION)

// Helper expansion macros (each does exactly one transform)
#define ANTZ_MSG_X_ID(PREFIX, id, ...) id,
#define ANTZ_MSG_X_ENUM(PREFIX, id, ...) PREFIX##_msg_e::id
#define ANTZ_MSG_X_FORMAT(PREFIX, id, level, fmt, ...) fmt,

#define ANTZ_MSG_X_STRINGF(PREFIX, id, level, fmt, types, ...)                              \
    inline const char* PREFIX##_MSGF_##id types {                                           \
        return PREFIX##_messagef(PREFIX##_msg_e::id __VA_OPT__(,) __VA_ARGS__);             \
    }

#define ANTZ_LOG_X_LEVEL(PREFIX, id, level, ...) level,

#define ANTZ_LOG_X_FUNCTION(PREFIX, id, level, fmt, types, ...)                             \
    inline void PREFIX##_LOG_##id types {                                                   \
        ANTZ_LOGF(PREFIX,  ANTZ_MSG_X_ENUM(PREFIX, id) __VA_OPT__(,) __VA_ARGS__)           \
    }

#if ANTZ_LOG_ENABLE
    #define ANTZ_LOGF(PREFIX, id, ...)                                                      \
        if constexpr ((PREFIX##_log_levels[int(id)]) >= ANTZ_LOG_MIN_LEVEL) {               \
            antz::logf(PREFIX##_log_levels[int(id)], int(id),                               \
            PREFIX##_msg_formats[int(id)] __VA_OPT__(,) __VA_ARGS__);                       \
        }
#else
    // Does nothing
    #define ANTZ_LOGF(PREFIX, id, ...) do {} while(0)
#endif



