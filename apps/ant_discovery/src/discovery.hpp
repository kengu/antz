#pragma once

#include <chrono>
#include <execinfo.h>
#include <set>
#include <string>
#include "types.h"
#include <cstdint>

namespace ant {

    enum class LogLevel {
        Fine,
        Info,
        Warn,
        Error,
        None = 256,
    };

    enum class AntProfile {
        Unknown,
        HeartRate,
        AssetTracker,
    };

    enum class OutputFormat {
        Text,
        JSON,
        CSV
    };

    struct Channel {
        bool use = true;
        uint8_t cNum = 0;
        uint8_t cType = 0;
        uint16_t dNum = 0;
        uint8_t dType = 0;
        uint8_t tType = 0;
        ushort period = 0;
        uint8_t rfFreq = 0;
        uint8_t searchTimeout = 0;
    };

    struct ChannelState {
        std::chrono::steady_clock::time_point lastSeen;
        int8_t lastRssi = 0;
        bool active = false;
    };

    // Enum for situation field in status byte
    enum class AssetSituation {
        Sitting = 0,
        Moving = 1,
        Pointed = 2,
        Treed = 3,
        Unknown = 4,
        Undefined = 255,
    };

    struct RxTimestampInfo {
        // The Rx Timestamp is a 2 byte field (16-bit value) that rolls
        // over every 2 seconds. This value is in little endian format.
        // The timestamp is based on a 32.768 kHz clock and is subject
        // to variance due to clock drift. The Rx timestamp is generated
        // exactly when the message was received by ANT over the air.
        uint16_t value = 0;
    };

    struct DeviceIdInfo {
        // The device number is a 16-bit field that is meant to be
        // unique for a given device type. Typically, this may be
        // correlated to the serial number of the device, or it could
        // be a random number generated by the device if the process
        // of setting serial numbers for a particular product is
        // unavailable. This parameter must be specified on a master
        // device, i.e. it cannot be set to zero. In a slave device,
        // this field may also be used as a wild card during device
        // pairing as described in the previous section. Please note
        // that the device number should not be set to 0x0000 or
        // 0xFFFF as these are reserved values, particularly if the
        // device number is derived from the serial number.
        uint16_t number = 0;

        // The device type is an 8-bit field used to denote the type
        // (or class) of each participating network device. This field
        // is used to differentiate between multiple nodes of network
        // devices such that participants are aware of the various
        // classes of connected nodes and can decode the received data
        // accordingly. For example, one device type value could be
        // assigned to heart rate monitors, which will be different to
        // the value assigned to bike speed sensors, and their respective
        // data payloads will be interpreted accordingly. Please note
        // that the most significant bit of the Device Type is a device
        // pairing bit. This parameter must be specified on a master
        // device; however, it can be set to zero (wildcard) on a slave
        // device.
        uint8_t dType = 0;

        // The transmission type is an 8-bit field used to define certain
        // transmission characteristics of a device. Specifically, the two
        // least significant bits of the transmission type are used to indicate
        // the presence, and size, of a shared address field at the beginning
        // of the data payload, and the third least significant bit (LSB) is
        // used to indicate the presence of a Global Data Identification
        // Byte (such as ANT+ page numbers). The most significant nibble
        // may optionally be used to extend the device number from 16 bits
        // to 20 bits. In this case, the transmission type most significant
        // nibble becomes the most significant nibble of the 20 bit device
        // number. This parameter must be specified on a master device;
        // however, it can be set to zero (wildcard) on a slave device.
        uint8_t tType = 0;
    };

    struct RssiInfo {
        // The measurement value represents the measurement type of
        // the received data message, and indicates how to interpret
        // the RSSI Value field. The measurement type will be 0x20,
        // which refers to DBM type. DBM type indicates that the RSSI
        // value is taken in units of dBm. If the measurement type is
        // any other value, do not decode any other bytes in the
        // extended RSSI data. For more information refer to the
        // “RSSI Extended Messaging” application note.
        uint8_t mType = 0;

        // The RSSI value is a signed integer that corresponds
        // to the measured RSSI value in dBm (can be negative).
        int8_t value = 0;

        // The threshold configuration value is used to indicate
        // the dBm value of the bin configured using the
        // Proximity Search command. The default value is -128dB,
        //  which corresponds to an effective “ Off” setting.
        uint8_t threshold = 0;
    };

    struct ExtendedInfo {
        uint8_t flags = 0;

        bool hasDeviceId = false;
        bool hasRxTsValue = false;
        bool hasRssiValue = false;

        RssiInfo rssi;
        RxTimestampInfo rxTs;
        DeviceIdInfo deviceId;

        // Length of extended info
        uint8_t length = 0;
    };

    struct NameInfo {
        std::string uName;
        std::string lName;
        std::string fName;
    };

    struct HRM {
        uint8_t heartRate = 0;
        ExtendedInfo ext;
    };

    struct Device {
        uint8_t index{};
        uint8_t color = 0;
        uint8_t aType = 0;

        NameInfo name{};
        uint16_t distance = 0;
        float headingDegrees = 0.0f;
        double lat = 0.0;
        double lon = 0.0;
        AssetSituation situation = AssetSituation::Unknown;

        bool gpsLost = false;
        bool commsLost = false;
        bool remove = false;
        bool lowBattery = false;

        std::chrono::system_clock::time_point ts; // Host timestamp of last update

        std::string batteryLevel = "?";
        std::string batteryVoltage = "?";

        ExtendedInfo ext;
    };

    struct ProductInfo {
        uint32_t serial{};
        double swVersion{};
        ExtendedInfo ext;
        std::chrono::system_clock::time_point ts; // Host timestamp of last update
    };

    struct ManufacturerInfo {
        uint16_t id;
        std::string name;
        std::string model;
        uint16_t number;
        int hwRevision;
        ExtendedInfo ext;
        std::chrono::system_clock::time_point ts; // Host timestamp of last update
    };

    struct BatteryInfo {
        uint8_t identBatt;
        uint8_t numOfBatt;
        std::string status;
        uint32_t uptime;
        double voltage;
        ExtendedInfo ext;
        std::chrono::system_clock::time_point ts; // Host timestamp of last update
    };

    // -----
    // Helper methods
    // -----

    inline std::string toAntProfileString(const AntProfile s) {
        switch (s) {
        case AntProfile::Unknown: return "Unknown";
        case AntProfile::HeartRate:   return "HRM";
        case AntProfile::AssetTracker:   return "Tracker";
        default:                        return "Invalid";
        }
    }

    // Converts meters to degrees latitude/longitude (approximate, valid for small distances)
    constexpr double metersToDegrees(const double meters) {
        constexpr double METERS_PER_DEGREE = 111320.0; // average Earth radius at mid-latitudes
        return meters / METERS_PER_DEGREE;
    }


    // -----
    // Public API
    // -----


    void setFormat(OutputFormat fmt);
    void setLogLevel(LogLevel level);
    void setSearch(const std::vector<AntProfile>& types);
    void setEpsLatLng(double meters);
    void setEpsHeading(double degrees);
    void setMqtt(const std::string& cnn);
    bool initialize(ULONG baud, UCHAR ucDeviceNumber);
    bool startDiscovery();
    void runEventLoop();
    void cleanup();
}
